# s5 - allocated memory

.eqv BUFFER_SIZE 24

.data

# number of append test cases
append_n:  .word 4
append_ins1:  .word
        # none,
        # none,
        1, 2, 3, 4,
        1, 2
append_numins1:  .word
        0,
        0,
        4,
        2
append_ins2:  .word
        # none,
        1, 2, 3, 4,
        # none,
        2, 3, 4, 5
append_numins2:  .word
        0,
        4,
        0,
        4
append_outs:  .word
        # none,
        1, 2, 3, 4,
        1, 2, 3, 4,
        1, 2, 2, 3, 4, 5
append_numouts:  .word
        0,
        4,
        4,
        6

# number of filter test cases
filter_n:  .word 2
filter_ins:  .word
        # none,
        1, 2, 3, 5
filter_numins:  .word
        0,
        4
filter_outs:  .word
        # none,
        1, 3, 5
filter_numouts:  .word
        0,
        3

# number of map test cases
map_n:  .word 2
map_ins:  .word
        # none,
        1, 3, 5, 7
map_numins:  .word
        0,
        4
map_outs:  .word
        # none,
        2, 4, 6, 8
map_numouts:  .word
        0,
        4

# number of foldl test cases
foldl_n:  .word 3
foldl_ins:  .word
        # none,
        1, 2, 3, 4,
        1, 2, 3, 4
foldl_numins:  .word
        0,
        4,
        4
foldl_initials:  .word
        2,
        5,
        24
foldl_outs:  .word
        2,
        15,
        64

# number of foldr test cases
foldr_n:  .word 3
foldr_ins:  .word
        # none,
        1, 2, 3, 4,
        1, 2, 3, 4
foldr_numins:  .word
        0,
        4,
        4
foldr_initials:  .word
        2,
        5,
        24
foldr_outs:  .word
        2,
        15,
        9

# number of reverse test cases
reverse_n:  .word 2
reverse_ins:  .word
        # none,
        1, 3, 5, 7
reverse_numins:  .word
        0,
        4
reverse_outs:  .word
        # none,
        7, 5, 3, 1
reverse_numouts:  .word
        0,
        4


.text

runner:
        li      $v0, 9                  # code for allocating heap memory
        li      $a0, BUFFER_SIZE        # specify BUFFER_SIZE bytes - length of longest expected output
        syscall
        move    $s5, $v0                # location of allocated memory is where callee writes result



        jal     run_append
        jal     run_filter
        jal     run_map
        jal     run_foldl
        jal     run_foldr
        jal     run_reverse

exit_ok:
        la      $a0, okmsg              # put address of okmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        li      $v0, 10                 # 10 is exit with zero status (clean exit)
        syscall

# helper function for testing filter
is_odd:
        andi    $v0, $a0, 1
        j       clear_working_registers

# helper function for testing map
increment:
        addi    $v0, $a0, 1
        j       clear_working_registers

# helper functions for testing foldl and foldr
add:
        add     $v0, $a0, $a1
        j       clear_working_registers

multiply:
        multu   $a0, $a1
        mflo    $v0
        j       clear_working_registers

divide:
        divu    $a0, $a1
        mflo    $v0
        # j       clear_working_registers

clear_working_registers:
        move $a0, $zero
        move $a1, $zero
        move $a2, $zero
        move $a3, $zero
        move $t0, $zero
        move $t1, $zero
        move $t2, $zero
        move $t3, $zero
        move $t4, $zero
        move $t5, $zero
        move $t6, $zero
        move $t7, $zero
        move $t8, $zero
        move $t9, $zero
        move $v1, $zero
        jr $ra


append_runner:

filter_runner:
        lw      $s0, 0($filter_n)
        la      $s1, filter_ins
        la      $s2, filter_numins
        la      $s3, filter_outs
        la      $s4, filter_numouts

run_test:
        la      $a0, is_odd
        move    $a1, filter_ins
        lw      $a2, 0($filter_numins)
        move    $a3, $s7
        jal     filter



filter_n:  .word 2
filter_ins:  .word
        # none,
        1, 2, 3, 5
filter_numins:  .word
        0,
        4
filter_outs:  .word
        # none,
        1, 3, 5
filter_numouts:  .word
        0,
        3





        jr      $ra

run_map:
        jr      $ra

run_foldl:
        jr      $ra

run_foldr:
        jr      $ra

run_reverse:
        jr      $ra



clear_output:
                                        # zero out output by storing zeros
        addi    $t0, $s7, BUFFER_SIZE   # pointer to end of output buffer

clear:
        subi    $t0, $t0, 4             # decrement pointer
        sw      $zero, 0($t0)           # store a 0 word
        bne     $t0, $s7, clear         # repeat util we have reached the start of the buffer
        jr      $ra

# # Include your implementation here if you wish to run this from the MARS GUI.
# .include "impl.mips"
