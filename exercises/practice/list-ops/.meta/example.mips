.globl append
.globl filter
.globl map
.globl foldl
.globl folr
.globl reverse

append:
        sll     $t0, $a1, 2             # bytes taken up currently by list one
        add     $t0, $a0, $t0           # output pointer, end of list one
        move    $t1, $a2                # input pointer, start of list two
        sll     $t2, $a3, 2             # bytes taken up by list two
        add     $t2, $a2, $t2           # pointer to end of list 2
        j       append_check

append_step:
        lw      $t3, 0($t1)
        addi    $t1, $t1, 4
        sw      $t3, 0($t0)
        addi    $t0, $t0, 4

append_check:
        bne     $t1, $t2, append_step   # repeat until we reach end of list 2
        sub     $v0, $t0, $a0           # bytes taken up by list one
        srl     $v0, $v0, 2             # number of words in list 1
        jr      $ra


filter:
        addi    $sp, $sp, -24           # allocate space on stack to preserve registers
        sw      $s0, 0($sp)
        sw      $s1, 4($sp)
        sw      $s2, 8($sp)
        sw      $s3, 12($sp)
        sw      $s4, 16($sp)
        sw      $ra, 20($sp)

        move    $s0, $a0                # predicate function to call on each input element
        move    $s1, $a1                # input pointer
        sll     $s2, $a2, 2             # bytes taken up by input
        add     $s2, $a1, $s2           # pointer to end of input
        move    $s3, $a3                # pointer to start of output
        move    $s4, $a3                # output pointer

# TODO: refactor to have beq at bottom (becomes bne),   here we need to jump to there
# same for map

filter_step:
        beq     $s1, $s2, filter_done
        lw      $a0, 0($s1)             # load input value
        jal     $s0                     # call predicate function
        lw      $a0, 0($s1)             # reload input value
        addi    $s1, $s1, 4             # advance input pointer
        jeqz    $v0, filter_step
        sw      $a0, 0($s4)
        addi    $s4, $s4, 4             # advance output pointer
        j       filter_step

filter_done:
        sub     $v0, $s4, $s3           # bytes taken up by output
        srl     $v0, $v0, 2             # number of output words
        lw      $ra, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, 24           # restore original stack pointer
        jr      $ra


map:
        addi    $sp, $sp, -24           # allocate space on stack to preserve registers
        sw      $s0, 0($sp)
        sw      $s1, 4($sp)
        sw      $s2, 8($sp)
        sw      $s3, 12($sp)
        sw      $s4, 16($sp)
        sw      $ra, 20($sp)

        move    $s0, $a0                # transform function to call on each input element
        move    $s1, $a1                # input pointer
        sll     $s2, $a2, 2             # bytes taken up by input
        add     $s2, $a1, $s2           # pointer to end of input
        move    $s3, $a3                # pointer to start of output
        move    $s4, $a3                # output pointer

map_step:
        beq     $s1, $s2, map_done
        lw      $a0, 0($s1)             # load input value
        addi    $s1, $s1, 4             # advance input pointer
        jal     $s0                     # call transform function
        sw      $v0, 0($s4)
        addi    $s4, $s4, 4             # advance output pointer
        j       map_step

map_done:
        sub     $v0, $s4, $s3           # bytes taken up by output
        srl     $v0, $v0, 2             # number of output words
        lw      $ra, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, 24           # restore original stack pointer
        jr      $ra


foldl:



        addi    $sp, $sp, -16           # allocate space on stack to preserve registers
        sw      $s0, 0($sp)
        sw      $s1, 4($sp)
        sw      $s2, 8($sp)
        sw      $ra, 12($sp)

        move    $s0, $a0                # transform function to call on each input element
        move    $s1, $a1                # input pointer
        sll     $s2, $a2, 2             # bytes taken up by input
        add     $s2, $a1, $s2           # pointer to end of input



we get initial - don't need to save, just keep in v0/a0
return address
f
input pointer
end of input

        move    $v0, 0
        jr      $ra


foldr:
        move    $v0, 0
        jr      $ra


reverse:
        move    $v0, 0
        jr      $ra
